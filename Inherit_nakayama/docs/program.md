# 実験の構成
## 全体像
プログラムの全体像は次の画像のようになっています.

![プログラムの全体像](image/program_gaiyou.PNG)

私のプログラムは基本的に赤で囲まれたShellscript（`.sh`でおわるファイル）で実行する仕様になっています.

図が複雑になるためにここでは掲載をしていませんが, 図で示されているプログラムの他にも私が作成した実行に関係するプログラムがあります.
以下にそれらのファイルの説明を記載します.


## 各プログラムファイルの説明
### convert_file.py
データの前処理などを行っているプログラムです.
本研究で用いたデータセットの構成はやや複雑になっています.
詳細は論文を参考にしてほしいのですが, ここでは概略図を添付いたします.

![データ構成の概略図]()

!!! Note
	実験に使用したデータセットは`/mnt/nas1/work/nakayama/py_file/m2/package/index`内に含まれています.
	実際の真値の値と比較したい場合に利用してください.

### experiment_***.sh
このファイルは中にpythonプログラムを実行するコードが含まれています.
具体的には,
<br>

>`python3 stock_lstm_2018_gamma.py -s ${COUNT} -g ${GAMMA}`

といった箇所になります.
`-g ${GAMMA}`は変数`GAMMA`が入る部分であり, 修士論文の中にある\( \gamma \)の値に対応しています.
具体的な値はShellscriptのファイル名にある値が入っています.
experiment_2.shとexperiment_3.shについては変数`GAMMA`の値は存在していません.
また,変数`COUNT`は**実験全体の**試行回数を表しています.

!!! Note
	ベイズ的最適化の試行回数は別途`optimization.py`の変数`self.num_iteration`で指定しています.

ファイルパスの部分は絶対パスで指定しているので, 自分が実行するファイルパスに調整してください.

### wavelet_scarogram_2.py
Wavelet変換および2次元相関係数の計算を行っているコードです.
Wavelet変換については関数`do_wavelet`において実行されています.

!!! Note
	この部分はPywaveletというライブラリにおけるExampleを参考にして作りました.
	以下にリンクを添付しますので参考までに確認すると理解の助けになるでしょう.


また,2次元相関係数`_cald`において行われており,「研究概要」のページで紹介した論文に従った形で実装を行っています.
モードとしては,

 * `all`
 * `row`
 * `col`

の3種類があります.
予備実験の結果,モード`row`（研究概要のページで示した相関係数）にしたものが結果が最も良かったためこちらを採用しています.

### stock_lstm_***.py
**ある\(\gamma\)の値における1回の実験全体**を行うためのファイルです.
`stock_lstm_2018_gamma.py`の場合と`stock_lstm_2(3).py`では入力`file_list`に与えられているデータが異なっています.

* `stock_lstm_2018_gamma.py`の場合
修士論文にある, 最も類似度の高いデータセットを「初期設計」にしたもの5種類,および最も類似度が低いデータセットを「初期設計」にしたもの5種類の合計10種類の株価指数データの組み合わせが入力です.
関数`do_wavelet`の返り値となっています.

* `stock_lstm_2(3).py`の場合
実験に使用した5種類の株価指数データをそのまま使用しています.

!!! Tip
	<div style="margin-left: 1em; text-indent: -1em;">
	<p>`except:`<br>
	`import traceback`<br>
	`error_request.send_error_log("You got error such as:" + traceback.format_exc())`</p>
	</div>
	の部分はSlackにエラーを通知するために私が仕込んだコードになります.
	このため, この部分は必ずしも必須ではありません.（すなわちtry-except文も必須ではありません）
	通知そのものは,`error_request.py`によって行われています.
	`https://hooks.slack.com/services/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"`
	と記載されている部分を自分のSlackのリンクに変更することで通知を送ることができます.
	参考にしたリンクはこちらです.
	[プログラムでエラーが発生したら即Slackに通知する！](https://tech.bita.jp/article/17)


### selection.py
基本的にはどの最適化手法を用いるかを具体的に分割したファイルです.

!!! Note
	ただし, **提案手法の実装である関数`series_dist_bo`では, プログラムの実行時間を削減するための処理を行っています.**
	具体的には, 初期設計を構成する際に必要な超パラメータ\(\)と検証誤差の組をそのまま計算するのではなく, **stock_lstm2.py(従来のベイズ的最適化を行うプログラム)で実行して得られたcsvファイルから値を取り出す**ということを行っています.

### optimization.py
ベイズ的最適化と最適化により与えられた機械学習モデルの学習の実行をひも付けするプログラムです.
`self._objective_function`がベイズ的最適化における関数\(f\), すなわち**機械学習モデル**を表しています.
<br>
また, この部分でライブラリRoBoにある関数および, RoBoを元に一部改変した**my_robo**ライブラリを呼び出しています.
**my_robo**ライブラリについては別の箇所で紹介します.


### write_csv.py
機械学習の枠組みにおけるテストデータでの誤差の計算結果（`result_score_***.csv`という形式で保存）および予測結果（`result_prediction_***.csv`という形式で保存）をCSV形式で保存するためのコードです.

### predict.py
機械学習モデルを実装しているコードになります.
具体的なモデルの概要は次の図になります.

![model_gaiyou](image/network_structure.PNG)

LSTMは多層構造になっており, LSTMの数もまた超パラメータになっています.


!!! Note
	修士論文時の実験では**DeepBeliefNetwork(DBN)**により, 事前学習を行った結果得られた重みをモデル全体に与えていました.
	現在の実験設定では外していますが, 江口先生とのミーティング次第では復活する可能性もあります.
	そのため,コードにもコメントアウトという形で残しておきます.
	この時,**バイアス**項には事前に重みを与えないことに注意してください.

!!! Failure
	本研究の実験では残念ながら**再現性が担保されていません**.
	この原因は, LSTMなどのモデルを構築する際に使用したKerasのバックエンドで動作している**Tensorflow**の仕様によるものです.
	Tensorflowでは, **GPU環境で動作させた際に乱数を固定した再現性のある学習が行うことができないことが報告されています.**(具体的なページはここに提示できませんが, 検索をすれば発見することができます.)
	<br>
	この問題の解決策として,私が推奨する方法は「Kerasではないライブラリで書き直す」です.
	最近ではKerasと同様にモデル構築が容易なライブラリとして**PyTorch**というライブラリが存在します.
	PyTorchにおいては,乱数を固定したモードでGPU環境でも再現性のある実験を行うことが可能です.
	少々手間のかかる作業にはなるかと思いますが, この作業を行うことにより,実験の評価がより正確になることが期待されます.